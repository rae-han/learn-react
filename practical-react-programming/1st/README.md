##  환경변수
- .env.{환경변수 이름} 으로 선언한 파일을 process.env.{환경 변수 이름} 으로 접근 가능하다.
- npm start -> development
- npm test -> test
- npm run build -> production

## CSS 작성 방법
- 리액트 프로그래밍은 컴포넌트를 중심으로 생각하는게 좋다.
- 컴포넌트 하나를 잘 만들어 여러 곳에 재사용 하는게 좋은데, 그러기 위해서는 각 컴포넌트는 서로 간의 의존성을 최소화하면서 내부적으로는 응집도(cohesion)를 높여야한다.
- 컴포넌트는 화면에 보이는 부분으로 당연히 CSS코드가 필요하고, 응집도를 높이기 위해 컴포넌트 내부에서 CSS 관리하는 방법으로는 css-module, css-in-js 가 있다.

### css-module
CRA에서는 css 파일 이름 접미사에 .module.css 를 사용하면 컴포넌트 단위의 css 모듈이 된다.

## 단일 페이지 애플리케이션
- 리액트 애플리케이션의 페이지 전환은 단일 페이지 애플리케이션(single page applicaiton, SPA)가 정석이다.
- 최초 요청 시 서버에서 첫 페이지를 처리하고 이후의 라우팅은 클라이언트에서 처리한다.

## 리액트 훅
- 로직을 재사용하는 기존 방식의 한계
  - 리액트에서 로직의 재사용은 주로 고차 컴포넌트와 렌더 속상값 패턴으로 이루어진다.
  - 두 방법은 대상이 되는 컴포넌트를 감싸는 새로운 컴포넌트를 생성하기 때문에 리액트 요소 트리가 깊어진다.
  - 리액트 요소 트리가 싶어지면 성능에 부정적인 영향이 있고, 개발 시 디버깅을 힘들게 하는 원인이 되기도 한다.

- 클래스형 컴포넌트의 한계
  - 서로 연관성이 없는 여러 가지 로직을 하나의 생명 주기 메서드에서 작성하는 경우가 많다.
    - componentDidMount 메서드에 등록 후, componentWillUnmount 메서드에서 해제
  - 컴포넌트를 작성할 때 부수적으로 작성해야 하는 코드가 많다.
  - 사람뿐만 아니라 컴퓨터의 입장에서도 복잡한 구조로 되어 있어 코드 압축이 잘 안 되는 경우가 있고, 핫 리로드에서 난해한 버그를 발생시키고, 컴파일 단계에서 코드를 최적화하기 어렵게 만든다.

- 훅의 장점
  - 훅을 사용하면 재사용 가능한 로직을 쉽게 만들 수 있다.
    - 훅이 단순한 함수이므로 함수 안에서 다른 함수를 호출하는 것으로 새로운 훅을 만들 수 있기 때문
  - 같은 로직을 한곳으로 모을 수 있다.
    - 같은 로직이 componentDidMount나 componentDidUpdate 에 중복으로 들어갈 일이 없다.
  - 단순한 함수이므로 정적 타입 언어로 타입을 정의하기 쉽다.
    - 귀찮고 까다로운 작업이었던 고차 컴포넌트의 타입 정의와 비교되는 부분

- useState 
  - 컴ㅍ넌트에 상탯값 추가
  - 여러개의 상탯값을 하나의 객체로 관리하는 경우를 위해 useReducer 훅이 제공
- useEffect
  - 함수형 컴포넌트에서 생명 주기 함수를 이용하는데 사용
  - 클래스형 컴포넌트의 메서드들과 1:1로 대응되진 않는다
    - 리액트 팀에서 기존의 생명 주기 메서드에 문제가 있다고 판단했기 때문

### 훅 사용시 규칙
1. 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야 한다.
2. 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다.

- 위의 두 규칙을 지켜야 리액트가 각 훅의 상태를 제대로 기억할 수 있다.

- useContext 
  - Consumer 컴포넌트를 사용하지 않고도 부모 컴포넌트로부터 전달된 컨텍스트 데이터를 사용 가능.
- useRef
  - 함수형 컴포넌트에서 돔 요소 접근
  - 함수형 컴포넌트에서 렌더링과 무관한 값 저장
    - 클래스형 컴포넌트에서는 렌더링과 무관한 값을 멤버 변수에 저장했다면,
    - 함수형 컴포넌트는 인스턴스로 생성되지 않기 때문에 사용된 컴포넌트의 고유한 값을 저장할 방법이 없엇다.
    - 이때 useRef 훅으로 맴버 변수를 만들수 있다.
      - useState 훅도 변수로 사용될 수 있지만 컴포넌트의 생명 주기와 밀접하게 연관되어 있어 렌더링과 무관한 값을 저장하기에는 적합하지 않다.
      - /component/PreValueRef.js 참조

- useMemo, useCallback
  - 메모제이션 훅

- useMemo
  - 계산량이 많은 함수의 반환값을 재활용하는 용도로 사용
  - 두 번째 매개변수로 입력된 배열의 값이 변경되지 않으면 이전에 반환된 값을 재사용한다.

- useCallback
  - useMemo 훅은 로다시 같은 라이브러리의 메모이제이션과 비슷하다면 useCallback은 리액트이 렌더링 선능을 위해 제공되는 훅이다.
  - 훅을 사용하게 되면서 컴포넌트가 렌더링될 때마다 함수를 생성해서 자식 컴포넌트의 속성값으로 입력하는 경우가 많다.
  - 리액트 팀에서는 함수 생성이 성능에 영향을 주기보다, 속성값이 매번 변경되기 때문에 자식 컴포넌트에서 PureComponent나 React.memo 를 사용해도 불필요한 렌더링이 발생한다는 문제점이 있는데 이걸 해결해 주는게 useCallback 훅을 사용한다.

- useReducer
  - 컴포넌트의 상탯값을 리덕스처럼 관리
  - 보통 상위 컴포넌트를 컨테이너 컴포넌트로 만들고 상태 값을 관리하면 자식 컴포넌트로부터 발생한 이벤트에서 컨테이너 컴포넌트의 상탯값을 변경해야 하는 경우가 많다.
  - 이를 위에 트리의 깊은 곳까지 이벤트 처리 함수를 전달하게되면 손이 많이 가고 코드의 가독성도 떨어진다.
  - 이때 useReducer 훅과 컨텍스트 API를 이용하면 상위 컴포넌트에서 트리의 깊은 곳으로 이벤트 처리 함수를 전달할 수 있다.
  - '/components/UseReducer.js 참고

- useImperativeHandle
  - 부모 컴포넌트에서 접근 가능한 함수 구현

- useLayoutEffct
  - useEffect 훅은 렌더링 결과가 돔에 반영된 후 비동기로 호출되는데 반해 useLayoutEffect는 동기로 호출된다.
  - 클래스 라이프사이클 메서드의 componentDidMount와 componentDidUpdate 메서드도 렌더링 결과가 돔에 반영된 직후 동기로 호출되므로, 훅으로 포팅한다면 useEffect보다는 useLayoutEffect 훅을 사용하는게 안전하다.
  - 하지만 연산을 많이하게 되면 브라우저가 먹통이 될수 있으므로 특별한 이유가 없다면 useEffect 훅을 사용하며, 렌더링 직후 돔 요소의 값을 읽는 경우 useLayoutEffect 훅을 사용하는 것이 적헙하다.

- useDebugValue
  - 개발 편의를 위해 제공되는 훅.
  - 커스텀 훅의 내부 상태를 관찰할 수 있다.
  - /hooks/useDebugValueToggle 참조
  - 여기 있는 값은 브라우저의 리액트 개발도구에서 확인 할수 있다.




# Redux

### 리덕스의 장점
  - 컴포넌트 코드로부터 상태관리 코드를 분리할 수 있다.
  - 서버 렌더링 시 데이터 전달이 간편하다.
  - 로컬 스토리지에 데이터를 저장하고 불러오는 코드를 쉽게 작성할 수 있다.
  - 같은 상탯값을 다수의 컴포넌트에서 필요로 할 때 좋다.
  - 부모 컴포넌트에서 깊은 곳에 있는 자식 컴포넌트에 상탯값을 ㅓㄴ달할 때 좋다.
  - 알림창과 같은 전역 컴포넌트의 상탯값을 관리할 때 좋다.
  - 페이지가 전환되어도데이터는 살아 있어야 할 때 좋다.

## 리덕시 사용시 따라야 할 세 가지 원칙
  1. 전체 상탯값을 하나의 객체에 저장한다.
  2. 상탯값은 불변 객체다.
  3. 상탯값은 순수 함수에 의해서만 변경되어야 한다.

1. 하나의 객체에 프로그램의 전체 상탯값을 저장한다.
  - 전체 상탯값이 자바스크립트 객체로 표현되기 때문에 활용도가 높아진다.
  - 리덕스 사용 시 하나의 객체를 직렬화(serialize)해서 서버와 클라이언트가 프로그램의 전체 상탯값을 서로 주고 받을 수 있다.
    - 프로그램이 특정한 상태에 있을 때 발생하는 버그를 확인하기 위해 상탯값을 저장한 후 반복해서 재현할 수 있다.
    - 최근의 상탯값을 버리지 않고 저장해 놓으면 실행 취소와 다시 실행 기능을 쉽게 구현할 수 있다.
  - 프로그램의 전체 상탯값을 리덕스로 관리하는 것은 쉬운 일이 아니다.
    - 애니메이션을 위한 데이터나 문자열 입력창의 현재 상탯값은 컴포넌트에서 관리하는게 더 나을수도 있다. 
    - 로직이 복잡하지 않은 페이지는 컴포넌트의 상탯값을 활용하는 게 생산성을 더 높일 수 있다.
  - 전체 상탯값을 리덕스로 관리하면 시간 여행(time travel)과 같은 기능을 쉽게 구현할 수 있지만, 그런 기능을 사용하지 않는다면 필요한 곳에서만 리덕스를 사용해도 된다.

2. 상탯값을 불변 객체로 관리한다.
  - 상탯값은 오직 액션 객체에 의해서만 변경되어야 한다.
  - 리덕스의 상탯값을 수정하는 유일한 방법은 액션 객체와 함께 dispatch 메서드를 호출하는 것.
    ```
    const incrementAction = {
      type: 'INCREMENT, // 액션 객체는 type 속성값이 존재해야 하고 액션 객체를 구분짓는 특징이다.
      amount: 123, // type 속성 값을 제외한 나머지는 상탯값을 수정하기 위해 사용되는 정보이다.
    }

    store.dispatch(incrementAction); // 액션 객체와 함께 dispatch 메서드를 호출하면 상탯값이 변경된다.
    ```
    - dispatch 메서드가 호출된 순서대로 리덕스 내부에서 변경되기 때문에 상탯값이 변화되는 과정을 쉽게 이해할 수 있다.
    - 액션 객체는 평범한 자바스크립트 객체이기 때문에 입력된 순서를 저장해 놓고 나중에 그 과정을 쉽게 재현할 수 있다.
    - 상탯값 수정이라는 하나의 목적만 놓고 보면 불변 객체를 사용하는 것보다 상탯값을 직접 수정하는게 빠르다.
      - 이전 상탯값과 이후 상탯값을비교해서 변경 여부를 파악할 때는 불변 객체가 유리하다.
      - 상탯값 변경을 빠르게 확인할 수 있으면 메모이제이션가 같은 기능을 활용하기 좋고, 리액트의 렌더링 성능을 올리는 데도 유리하다.

3. 오직 순수 함수에 의해서만 상탯값을 변경해야 한다.
  - 리덕스에서 상탯값을 변경하는 함수를 리듀서(reducer)라 부른다.
  - 리듀서의 대략적인 구조는 다음과 같은데, 이전 상탯값과 액션 객체를 입력으로 받아 새로운 상탯값을 만드는 순수 함수이다.
  ```js
  (state, action) => nextState;
  ```
  순수 함수는 부수 효과(side effect)를 발생시키지 않아야 한다. 이건 같은 인수에 대해 항상 같은 값을 반환해야 한단 뜻이다.
  ```js
    // 아래 두 코드 모두 < 홍길동님 안녕하세요. 지금은 11시 30분입니다 > 라는 로그가 출력된다.
    sayHello('홍길동'); // 1. 내부 적으로 시간 함수가 있다.
    sayHello('홍길동', '11:30'); // 2.
  ```
  1번 함수는 내부 적으로 시간 함수(비슷한 예로 랜덤 함수)를 호출하기 때문에 순수 함수가 아니다. 같은 인수라도 호출하는 시점에 따라 다른 값을 반환하기 때문이다. 2번 함수는같은 인수를 입력하면 항상 같은 값을 반환하는 순수함수이다.
  이런 특성으로 인해 순수 함수는 테스트 코드를 작성하기 쉽다.


## 리덕스 주요 개념
컴포넌트 ----------------------------------
| 액션 -> 미들웨어 -> 리듀서 -> 스토어 -> |
|   <-------------- 뷰 <----------------- |
-------------------------------------------

1. 액션
  - type 속성 값을 가진 자바스크립트 객체
  - dispatch 메서드에 넣어서 호출하면 상탯값을 변경하기 위한 과정을 수행한다.
  - 각 액션은 고유한 type 속성값을 사용해야 하기에 접두사를 붙이는 방법이 많이 사용된다.
```js
// todo.js
store.dispatch({ type: 'ADD', title: 'react', priority: 'high' });
store.dispatch({ type: 'REMOVE', id: 123 });
store.dispatch({ type: 'REMOVE_ALL' });

store.dispatch({ type: 'todo/ADD', title: 'react', priority: 'high' });
store.dispatch({ type: 'todo/REMOVE', id: 123 });
store.dispatch({ type: 'todo/REMOVE_ALL' });

store.dispatch(ADD);
```

  - dispatch 메서드를 호출할 때 직접 액션 객체를 입력하는 방법은 사용하지 않는게 좋다
    - ex. dispatch({ type: 'ADD', title: 'react', priority: 'high' });
  - todo/ADD 액션의 경우 title, priority 속성 값이 항상 존재하도록 강제할 필요가 있는데 생성자 함수를 이용해 해결할 수 있다.
  - 이 경우 나중에 액션 객체의 구조를 변경할 때도 액션 생성자 함수만 수정하면 된다.
```js
function addTodo({ title, priority }) {
  return { type: 'todo/ADD', title, priority };
}

store.dispatch(addTodo({ title: '영화보기', priority: 'high' }));
```

  - type 속성값은 리듀서에서 액션 객체를 구분할 때도 사용되기 때문에 상수 변수로 만드는 게 좋다.
```js
export const ADD = 'todo/ADD';

export function addTodo({ title, priority }) {
  return { type: ADD, title, priority };
}
```
  - type 이름을 상수 변수로 만들었다. 이 변수는 리듀서에서도 필요하기 때문에 export 키워드로 외부에 노출시킨다.
  - 액션 생성자 함수도 마찮가지다.
  - 앞의 리덕스 세 가지 원칙에 위배되지 않으므로 액션 생성자 함수에서는 부수 효과를 발생시켜도 된다.
    - 예를 들면 addTodo 함수에서 새로운 할일을 서버에 저장하기 위해 API 호출을 할 수 있다.

2. 미들웨어.
  - 미들웨어는 리듀서가 액션을 처리하기 전에 실행되는 함수.
  - 더버깅 목적으로 상탯값 변경 시 로그를 출력하건, 리듀서에서 발생한 예외를 서버로 전송하는 등의 목적으로 활용할 수 있다.
  - 리덕스 사용 시 특별히 미들웨어를 설정하지 않았다면 발생한 액션은 곧바로 리듀서로 보내진다.
  - 미들 웨어의 기본 구조는 const middleware = store => next => action => next(action) 이다.
  - 구조에서 알수 있듯 미들웨어는 스토어와 액션 객체를 기반으로 필요한 작업을 수행할 수 있다.
  - next 함수를 호출하면 다른 미들웨어 함수가 호출되고 최종적으로 리듀서 함수가 호출된다.
  - 6redux/src/lib/redux/middleware1.js